<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN" "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en">
<head>
    <meta http-equiv="Content-Language" content="en" />
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    <meta name="generator" content="WWW::AdventCalendar v1.112" />
    <link rel="alternate" title="Perl Advent Calendar 2019 XML feed" href="atom.xml" type="application/atom+xml" />
    <link rel="shortcut icon" href="favicon.ico" />
    <link rel="stylesheet" href="style.css" type="text/css" />
    <link rel="stylesheet" href="2019.css" type="text/css" />
    <title>
Perl Advent Calendar 2019 - 
Controlling your Terminal with Perl

</title>
</head>
<body>
    <div id="contentwrapper">
        <div id="header">
            <h1><a href="index.html">Perl Advent Calendar 2019</a></h1>
        </div>

        <p id="tagline">2019 twenty four merry days of Perl
         <a class='feed' href="atom.xml">Feed</a>
        </p>

        <div id="content">
          

<h1 class='title'>Controlling your Terminal with Perl</h1>
<div class='subtitle'>iTerm and Perl - 2019-12-20</div>

<div class='pod'><p><a href="https://iterm2.com/">iTerm</a> is a heck of a terminal emulator for macOS. Not only is it rock solid, fast, and efficient - it&#39;s also exteremly powerful - and can both be controlled <b>by Perl</b> and <b>can control Perl</b>.</p>

<h3 id="Are-We-Nearly-There-Yet">Are We Nearly There Yet?</h3>

<p>In addition to the standard control sequences iTerm supports <a href="https://iterm2.com/documentation-escape-codes.html">Proprietary Escape Codes</a> that can get it to do non-standard things a real dumb terminal would never be able to do.</p>

<p>For example, my standard wrapper for running tests in Perl looks like this:</p>

<pre><code>   perl -e &#39;print &quot;\e]50;ClearScrollback\a&quot;&#39; &amp;&amp;
   yath -v -Ilib t/01mytest.t \
   &amp;&amp; perl -e &#39;print &quot;\e]9;\nALL OK\a&quot;&#39; || perl -e &#39;print &quot;\e]9;\nFAILED\a&quot;&#39;</code></pre>

<p>That first sends the control sequence to clear the screen and delete all history (so scrolling to the top takes me to the top of the test.) It then runs the tests, and I can go make a cup of tea, because the script will send a notification that&#39;ll bleep as soon as tests are done running to tell me if it&#39;s succeeded or failed.</p>

<h3 id="Clickable-Links">Clickable Links</h3>

<p>Another neat trick that iTerm supports allowing programs to markup their output so that text becomes clickable. For example this creates a clickable link to google about Perl.</p>

<table class='code-listing'><tr><td class='line-numbers'><br /><code>1:&nbsp;<br />2:&nbsp;<br />3:&nbsp;<br />4:&nbsp;<br />5:&nbsp;</code><br />&nbsp;</td><td class='code'><br /><code><span class="word">print</span> <span class="double">&quot;Search more about &quot;</span><span class="structure">;</span><br /><span class="keyword">my</span> <span class="symbol">$href</span> <span class="operator">=</span> <span class="single">'http://google.com?q=Perl'</span><span class="structure">;</span><br /><span class="keyword">my</span> <span class="symbol">$text</span> <span class="operator">=</span> <span class="single">'Perl'</span><span class="structure">;</span><br /><span class="word">print</span> <span class="double">&quot;\e]8;;$href\a$text\e]8;;\a&quot;</span><span class="structure">;</span><br /><span class="word">print</span> <span class="double">&quot;.\n&quot;</span><span class="structure">;</span></code><br />&nbsp;</td></table>

<p>Of course, the links don&#39;t have to be pages on the web - you can trigger anything that has a URL scheme on macOS. Here I can click on the bullet point links to add them to OmniFocus:</p>

<table class='code-listing'><tr><td class='line-numbers'><br /><code>1:&nbsp;<br />2:&nbsp;<br />3:&nbsp;<br />4:&nbsp;<br />5:&nbsp;<br />6:&nbsp;<br />7:&nbsp;<br />8:&nbsp;<br />9:&nbsp;<br />10:&nbsp;<br />11:&nbsp;<br />12:&nbsp;</code><br />&nbsp;</td><td class='code'><br /><code><span class="comment">#!/usr/bin/perl<br /></span><br /><span class="keyword">use</span> <span class="float">5.024</span><span class="structure">;</span><br /><span class="keyword">use</span> <span class="pragma">warnings</span><span class="structure">;</span><br /><span class="keyword">use</span> <span class="pragma">experimental</span> <span class="single">'signatures'</span><span class="structure">;</span><br /><br /><span class="word">say</span> <span class="double">&quot;* &quot;</span><span class="operator">.</span><span class="word">clickable_link</span><span class="structure">(</span><span class="single">'Buy Milk'</span><span class="operator">,</span> <span class="single">'omnifocus:///add?name=Buy%20milk'</span><span class="structure">);</span><br /><span class="word">say</span> <span class="double">&quot;* &quot;</span><span class="operator">.</span><span class="word">clickable_link</span><span class="structure">(</span><span class="single">'Debug Program'</span><span class="operator">,</span> <span class="single">'omnifocus:///add?name=Debug%20Program'</span><span class="structure">);</span><br /><br /><span class="keyword">sub</span> <span class="word">clickable_link</span><span class="prototype">($text, $href)</span> <span class="structure">{</span><br />&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">return</span> <span class="double">&quot;\e]8;;$href\a$text\e]8;;\a&quot;</span><span class="structure">;</span><br /><span class="structure">}</span></code><br />&nbsp;</td></table>

<h3 id="Clickable-Recognizable-Text">Clickable Recognizable Text</h3>

<p>So far we&#39;ve been talking about having the programs running in the terminal in control. What if we want to do it the other way round - configure the terminal to react to things in the terminal and decide what to do itself?</p>

<p>This kind of thing is configured in the <i>Profiles</i> section of iTerm&#39;s preferences. iTerm can be configured to switch to any profile you create automatically. For example here I&#39;ve configured it to switch to this profile whenever I&#39;m in the <code>RuleTheWorld</code> project dir in my homedir.</p>

<p><center><img src="autoswitch.png" width="542" height="507" ></center>

</p>



<p>Now I can click on the <code>Edit</code> button below <code>Smart Selection</code> to define some new selection rules. Let&#39;s create one for Perl error messages.</p>

<p><center><img src="perlerr.jpg" width="804" height="354" ></center>

</p>



<p>Now if if hit <code>Edit</code> I can start defining context menu opens for when I right click on anything that matches the regex. The first menu item I create can also be activated by cmd-clicking on the match.</p>

<p><center><img src="actions.jpg" width="564" height="282" ></center>

</p>



<p>Now when I command-click on an error message it&#39;ll open the file in VSCode at the right line number.</p>

<h3 id="Triggers">Triggers</h3>

<p>Triggers are similar to clickable text, except you don&#39;t have to click on them - they happen immediately as the terminal sees the text being sent to it.</p>

<p>For example, you might recognize the message Hypnotoad prints out when starting up and open the browser window. Or you might have a command on the remove server print out something (like a file name) in a recognizable format and have the local machine do something like it (such as trigger a script to download that file and open in the editor).</p>

<p>One of my all time favorite hacks is to have iTerm color code the backgrounds of my Perl error messages so they&#39;re easy to spot.</p>

<p><center><img src="highlight.png" width="558" height="108" ></center>

</p>



<p>I use two different colors for the highlighting - red indicates the error message came from an absolute path (meaning it&#39;s an installed library, not my code, and I&#39;m less likely to change it) whereas green means it&#39;s local code that I probably need to fix.</p>

<p><center><img src="term.png" width="512" height="281" ></center>

</p>



<p>Of course, combined with the previous tip, I can cmd-click on these links to open them in vscode.</p>

<h3 id="Complete-Control">Complete Control</h3>

<p>For the ultimate control you can have iTerm start a &quot;coprocess&quot;. This means that as well as rendring what it&#39;s being sent it&#39;ll also send a copy to an external running program (a <i>co-process</i>.) That process can either simply monitor what&#39;s being printed to the terminal, or it can send it&#39;s own output which will be interpreted as the user having typed that at the terminal.</p>

<p>Coprocessses can be started manually, or by a user key combination, or even by a trigger recognizing some text that indicates a program you want to control automatically from you</p>

<h3 id="Syncing-our-lib-directory">Syncing our <code>lib</code> directory</h3>

<p>One cool trick I use coprocesses for is transferring my <code>lib</code> directory of custom modules to any machine I&#39;m connected to. Rather than worrying about if that machine can access the internet, if I can put the fils in my home directory somewhere insecure or not, or if I can connect directly to the machine I&#39;m logged into to transfer files - I have a different solution.</p>

<p>I just type them in again on each machine.</p>

<p>Or rather, the co-process does this for me. Here&#39;s an the example coprocess script to transfer the lib directory.</p>

<pre><code>    #!/bin/sh

    echo &#39;stty_orig=`stty -g`&#39;
    echo &#39;stty -echo&#39;
    echo &#39;clear&#39;
    echo &#39;echo &quot;Please wait, transfering&quot;&#39;
    echo &quot;cd ~&quot;;
    echo &quot;base64 -d | tar -xzf -&quot;
    cd ~
    tar -czf - -C ~ lib | base64 -b 72
    perl -e &#39;print &quot;\x{04}&quot;&#39;
    echo &#39;clear&#39;
    echo &#39;echo &quot;All done!&quot;&#39;
    echo &#39;stty $stty_orig&#39;</code></pre>

<p>If you squint hard enough you can actually work out what this is doing. It types a command on the remote machine to base64 decode anything that the user types and send it to tar to spit out to the filesystem. It then runs a command locally to tarball up the lib dir and print out the base64 encoding - effectively typing it over the wire to the command we just set up. It finally sends a ctrl-d to let the other end we&#39;re done before resetting the terminal.</p>

<h3 id="Conclusion">Conclusion</h3>

<p>I&#39;ve barely scratchd the surface of what iTerm2 can do here, but I hope I&#39;ve convinced you to give yourself th gift of an optimized environment this year!</p>

</div>

<div id='author'>
<img alt='Gravatar Image' style='vertical-align:middle' src=http://www.gravatar.com/avatar/5d71b5f0c61e97cd452d625cc24a4c82?r=g&s=80&d=retro />
This article contributed by: Mark Fowler &lt;mark@twoshortplanks.com&gt;
</div>


<ul id="pager">
    <li class="previous"><a title="Memories of Past Lives" href="2019-12-19.html">Previous</a></li>

    <li class="next"><a title="Test2: Test Harder (but easier)" href="2019-12-21.html">Next</a></li>
</ul>
<div style="clear: both"></div>

        </div>

    </div>



</body>
</html>





